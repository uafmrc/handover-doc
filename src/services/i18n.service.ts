import i18next from "i18next";

export const translations = {
  it: {
    translation: {
      readme: {
        title: "Documentazione generata automaticamente per il passaggio di consegne",
        summary: "Sommario del Progetto",
        stats: "Statistiche",
        totalFiles: "File totali",
        totalLines: "Righe di codice",
        languages: "Linguaggi",
        totalFunctions: "Funzioni totali",
        entryPoints: "Entry Points",
        patterns: "Pattern Architetturali",
        dependencies: "Dipendenze",
        production: "Produzione",
        development: "Sviluppo",
        usefulLinks: "Link Utili",
        detailedArchitecture: "Architettura Dettagliata",
        projectSetup: "Setup Progetto",
        generatedOn: "Documentazione generata il",
      },
      architecture: {
        title: "Architettura",
        overview: "Panoramica dell'Architettura",
        layers: "Livelli (Layers)",
        applicationLayers: "Layer dell'Applicazione",
        patterns: "Pattern Rilevati",
        fileMap: "Mappa dei File",
        mainComponents: "Componenti Principali",
        purpose: "Scopo",
        keyFunctions: "Funzioni principali",
        complexity: "ComplessitÃ ",
        mainFlows: "Flussi Principali",
        manualFlowsNote: "Da documentare manualmente in base ai casi d'uso specifici",
        internalDependencies: "Dipendenze Interne",
      },
      setup: {
        title: "Guida al Setup",
        prerequisites: "Prerequisiti",
        nodeVersion: "Node.js (versione da verificare in package.json)",
        npmYarn: "npm o yarn",
        installation: "Installazione",
        cloneRepo: "Clone del repository",
        installDeps: "Installazione dipendenze",
        copyConfig: "Copia file di configurazione",
        projectStartup: "Avvio del Progetto",
        development: "Sviluppo",
        build: "Build",
        production: "Produzione",
        configuration: "Configurazione",
        envVars: "Variabili d'ambiente necessarie (da verificare nel progetto)",
        envVarsNote: "Da compilare in base al progetto",
        testing: "Testing",
        runTests: "Esegui test",
        testCoverage: "Test con coverage",
        importantNotes: "Note Importanti",
        externalCreds: "Verificare le credenziali necessarie per servizi esterni",
        thirdPartyDocs: "Controllare la documentazione delle API di terze parti",
        accessConfig: "Assicurarsi che tutti gli accessi siano configurati correttamente",
      },
      api: {
        title: "Riferimento API",
        endpoints: "Endpoints",
        models: "Modelli",
        noApiDetected: "Nessun file API rilevato automaticamente",
        endpointsDetected: "Endpoints Rilevati",
        usage: "Utilizzo",
      },
      html: {
        overview: "Panoramica",
        architecture: "Architettura",
        fileMap: "Mappa File",
        dependencies: "Dipendenze",
        files: "Analisi File",
        search: "Cerca file...",
        all: "Tutti",
        highComplexity: "Alta ComplessitÃ ",
        lowScore: "Score Basso",
        lastUpdate: "Ultimo aggiornamento",
        changeTheme: "Cambia Tema",
        generatedOn: "Generato il",
        technicalHandover: "Documentazione Tecnica & Handover",
        executiveSummary: "Sommario Esecutivo",
        languagesDistribution: "Distribuzione",
        complexityFileAnalysis: "Analisi File",
        envVars: "Variabili d'Ambiente",
        apiRoutes: "API Routes",
        techDebt: "Debito Tecnico",
        techDebtDescription: "Rappresenta il costo del lavoro aggiuntivo necessario in futuro causato da soluzioni rapide ma non ottimali.",
        techDebtTitle: "Cos'Ã¨ il Debito Tecnico?",
        techDebtComplexity: "Punti extra per file con logica complessa.",
        techDebtTodo: "2 punti per ogni attivitÃ  rimandata trovata.",
        framework: "Framework",
        totalFiles: "File Totali",
        totalLines: "Righe di Codice",
        languages: "Linguaggi",
        functions: "Funzioni",
        database: "Database",
        detectedType: "Tipo Rilevato",
        schemaFile: "Schema File",
        modelsTables: "Modelli / Tabelle",
        infrastructure: "Infrastruttura",
        detected: "Rilevato",
        noDocker: "Nessuna configurazione Docker rilevata",
        noPipeline: "Nessuna pipeline rilevata",
        projectArchitecture: "Architettura del Progetto",
        layerStructure: "Struttura a Layer",
        interactive: "Interattiva",
        detailedAnalysis: "Analisi Dettagliata",
        searchPlaceholder: "Cerca file o funzioni...",
        complexityTitle: "ComplessitÃ ",
        qualityScoreTitle: "Quality Score",
        keyFunctions: "Funzioni Chiave",
        improvements: "Suggerimenti",
        noFilesFound: "Nessun file trovato",
        generatedBy: "Generated by Handover Doc Generator",
        createdBy: "Created with â¤ï¸ by Marco Lattanzi",
        chartFilesNumber: "Numero File",
        chartFilesScore: "File per Punteggio",
        chartScoreLabel: "Punteggio (1-10)",
      },
      cli: {
        start: "ğŸš€ Avvio generazione documentazione...\n",
        project: "ğŸ“ Progetto: {{name}}",
        path: "ğŸ“‚ Path: {{path}}",
        output: "ğŸ“¤ Output: {{dir}}\n",
        phase1: "ğŸ” Fase 1: Analisi del codice...",
        analyzedFiles: "âœ… Analizzati {{count}} file ({{lines}} righe)\n",
        phase2: "ğŸ¤– Fase 2: Analisi con Handover...",
        brainError: "âŒ Brain non raggiungibile. Assicurati che sia in esecuzione.",
        brainHint: "ğŸ’¡ Avvia Brain con: brain serve",
        apiKeyError: "âŒ API key non configurata",
        progress: "\r   Progresso: {{current}}/{{total}} file analizzati",
        analysisComplete: "\nâœ… Analisi completata\n",
        phase3: "ğŸ“ Fase 3: Generazione sommario progetto...",
        summaryGenerated: "âœ… Sommario generato\n",
        phase4: "ğŸ¨ Fase 4: Generazione report HTML...",
        htmlSaved: "âœ… Report HTML salvato: {{path}}\n",
        phase5: "ğŸ“„ Fase 5: Generazione documentazione Markdown...",
        markdownSaved: "âœ… Documentazione Markdown salvata\n",
        success: "ğŸ‰ Documentazione generata con successo!",
        filesGenerated: "\nğŸ“ File generati in: {{dir}}",
        reportHtml: "   - handover-report.html (report completo)",
        readmeMd: "   - README.md (panoramica)",
        architectureMd: "   - ARCHITECTURE.md (architettura)",
        setupMd: "   - SETUP.md (istruzioni setup)",
        apiMd: "   - API.md (documentazione API)",
        genError: "\nâŒ Errore durante la generazione: {{message}}",
        configNotFound: "âŒ File di configurazione non trovato: {{path}}",
        configHint: "\nğŸ’¡ Suggerimento: Copia config.example.json in config.json e modifica i parametri",
        initFileExists: "âŒ Il file {{path}} esiste giÃ ",
        initSuccess: "âœ… File di configurazione creato: {{path}}",
        initNextSteps: "\nğŸ’¡ Prossimi passi:",
        initStep1: "   1. Modifica il file config.json con i tuoi parametri",
        initStep2: "   2. Esegui: handover-doc generate",
        initError: "âŒ Errore durante la creazione del file: {{message}}"
      },
      debug: {
        title: "ğŸ” DEBUG - Rilevamento File con Path Profonde\n",
        project: "ğŸ“ Progetto: {{path}}\n",
        test1: "Test 1: Pattern **/*.ts",
        foundTs: "âœ… Trovati {{count}} file .ts",
        error: "âŒ Errore: {{message}}",
        test2: "\nTest 2: Pattern con profonditÃ  illimitata",
        foundJs: "âœ… Trovati {{count}} file TypeScript/JavaScript",
        depthStats: "\nğŸ“Š File per livello di profonditÃ :",
        depthLevel: "   Livello {{depth}}: {{count}} file",
        deepFiles: "\nğŸ”ï¸  File con path piÃ¹ profonde:",
        test3: "\nTest 3: Verifica file specifico \"{{file}}\"",
        exists: "   Esiste: {{status}}",
        yes: "âœ… SÃ¬",
        no: "âŒ No",
        size: "   Dimensione: {{count}} caratteri",
        lines: "   Righe: {{count}}",
        readError: "   âŒ Errore lettura: {{message}}",
        complete: "\nâœ¨ Debug completato!\n"
      }
    }
  },
  en: {
    translation: {
      readme: {
        title: "Automatically generated documentation for handover",
        summary: "Project Summary",
        stats: "Statistics",
        totalFiles: "Total Files",
        totalLines: "Lines of Code",
        languages: "Languages",
        totalFunctions: "Total Functions",
        entryPoints: "Entry Points",
        patterns: "Architectural Patterns",
        dependencies: "Dependencies",
        production: "Production",
        development: "Development",
        usefulLinks: "Useful Links",
        detailedArchitecture: "Detailed Architecture",
        projectSetup: "Project Setup",
        generatedOn: "Documentation generated on",
      },
      architecture: {
        title: "Architecture",
        overview: "Architecture Overview",
        layers: "Layers",
        applicationLayers: "Application Layers",
        patterns: "Detected Patterns",
        fileMap: "File Map",
        mainComponents: "Main Components",
        purpose: "Purpose",
        keyFunctions: "Main functions",
        complexity: "Complexity",
        mainFlows: "Main Flows",
        manualFlowsNote: "To be documented manually based on specific use cases",
        internalDependencies: "Internal Dependencies",
      },
      setup: {
        title: "Setup Guide",
        prerequisites: "Prerequisites",
        nodeVersion: "Node.js (version to be checked in package.json)",
        npmYarn: "npm or yarn",
        installation: "Installation",
        cloneRepo: "Clone the repository",
        installDeps: "Install dependencies",
        copyConfig: "Copy configuration files",
        projectStartup: "Project Startup",
        development: "Development",
        build: "Build",
        production: "Production",
        configuration: "Configuration",
        envVars: "Necessary environment variables (to be verified in the project)",
        envVarsNote: "To be filled based on the project",
        testing: "Testing",
        runTests: "Run tests",
        testCoverage: "Test with coverage",
        importantNotes: "Important Notes",
        externalCreds: "Verify necessary credentials for external services",
        thirdPartyDocs: "Check third-party API documentation",
        accessConfig: "Ensure all accesses are correctly configured",
      },
      api: {
        title: "API Reference",
        endpoints: "Endpoints",
        models: "Models",
        noApiDetected: "No API files automatically detected",
        endpointsDetected: "Detected Endpoints",
        usage: "Usage",
      },
      html: {
        overview: "Overview",
        architecture: "Architecture",
        fileMap: "File Map",
        dependencies: "Dependencies",
        files: "File Analysis",
        search: "Search files...",
        all: "All",
        highComplexity: "High Complexity",
        lowScore: "Low Score",
        lastUpdate: "Last update",
        changeTheme: "Change Theme",
        generatedOn: "Generated on",
        technicalHandover: "Technical Documentation & Handover",
        executiveSummary: "Executive Summary",
        languagesDistribution: "Distribution",
        complexityFileAnalysis: "File Analysis",
        envVars: "Environment Variables",
        apiRoutes: "API Routes",
        techDebt: "Technical Debt",
        techDebtDescription: "Represents the cost of additional work needed in the future caused by quick but non-optimal solutions.",
        techDebtTitle: "What is Technical Debt?",
        techDebtComplexity: "Extra points for files with complex logic.",
        techDebtTodo: "2 points for each postponed task found.",
        framework: "Framework",
        totalFiles: "Total Files",
        totalLines: "Lines of Code",
        languages: "Languages",
        functions: "Functions",
        database: "Database",
        detectedType: "Detected Type",
        schemaFile: "Schema File",
        modelsTables: "Models / Tables",
        infrastructure: "Infrastructure",
        detected: "Detected",
        noDocker: "No Docker configuration detected",
        noPipeline: "No pipeline detected",
        projectArchitecture: "Project Architecture",
        layerStructure: "Layer Structure",
        interactive: "Interactive",
        detailedAnalysis: "Detailed Analysis",
        searchPlaceholder: "Search files or functions...",
        complexityTitle: "Complexity",
        qualityScoreTitle: "Quality Score",
        keyFunctions: "Key Functions",
        improvements: "Improvements",
        noFilesFound: "No files found",
        generatedBy: "Generated by Handover Doc Generator",
        createdBy: "Created with â¤ï¸ by Marco Lattanzi",
        chartFilesNumber: "Number of Files",
        chartFilesScore: "Files per Score",
        chartScoreLabel: "Score (1-10)",
      },
      cli: {
        start: "ğŸš€ Starting documentation generation...\n",
        project: "ğŸ“ Project: {{name}}",
        path: "ğŸ“‚ Path: {{path}}",
        output: "ğŸ“¤ Output: {{dir}}\n",
        phase1: "ğŸ” Phase 1: Code analysis...",
        analyzedFiles: "âœ… Analyzed {{count}} files ({{lines}} lines)\n",
        phase2: "ğŸ¤– Phase 2: Handover analysis...",
        brainError: "âŒ Brain not reachable. Make sure it is running.",
        brainHint: "ğŸ’¡ Start Brain with: brain serve",
        apiKeyError: "âŒ API key not configured",
        progress: "\r   Progress: {{current}}/{{total}} files analyzed",
        analysisComplete: "\nâœ… Analysis complete\n",
        phase3: "ğŸ“ Phase 3: Project summary generation...",
        summaryGenerated: "âœ… Summary generated\n",
        phase4: "ğŸ¨ Phase 4: HTML report generation...",
        htmlSaved: "âœ… HTML report saved: {{path}}\n",
        phase5: "ğŸ“„ Phase 5: Markdown documentation generation...",
        markdownSaved: "âœ… Markdown documentation saved\n",
        success: "ğŸ‰ Documentation generated successfully!",
        filesGenerated: "\nğŸ“ Files generated in: {{dir}}",
        reportHtml: "   - handover-report.html (complete report)",
        readmeMd: "   - README.md (overview)",
        architectureMd: "   - ARCHITECTURE.md (architecture)",
        setupMd: "   - SETUP.md (setup instructions)",
        apiMd: "   - API.md (API documentation)",
        genError: "\nâŒ Error during generation: {{message}}",
        configNotFound: "âŒ Configuration file not found: {{path}}",
        configHint: "\nğŸ’¡ Hint: Copy config.example.json to config.json and edit parameters",
        initFileExists: "âŒ File {{path}} already exists",
        initSuccess: "âœ… Configuration file created: {{path}}",
        initNextSteps: "\nğŸ’¡ Next steps:",
        initStep1: "   1. Edit config.json with your parameters",
        initStep2: "   2. Run: handover-doc generate",
        initError: "âŒ Error during file creation: {{message}}"
      },
      debug: {
        title: "ğŸ” DEBUG - File Detection with Deep Paths\n",
        project: "ğŸ“ Project: {{path}}\n",
        test1: "Test 1: Pattern **/*.ts",
        foundTs: "âœ… Found {{count}} .ts files",
        error: "âŒ Error: {{message}}",
        test2: "\nTest 2: Pattern with unlimited depth",
        foundJs: "âœ… Found {{count}} TypeScript/JavaScript files",
        depthStats: "\nğŸ“Š Files per depth level:",
        depthLevel: "   Level {{depth}}: {{count}} files",
        deepFiles: "\nğŸ”ï¸  Files with deepest paths:",
        test3: "\nTest 3: Verify specific file \"{{file}}\"",
        exists: "   Exists: {{status}}",
        yes: "âœ… Yes",
        no: "âŒ No",
        size: "   Size: {{count}} characters",
        lines: "   Lines: {{count}}",
        readError: "   âŒ Read error: {{message}}",
        complete: "\nâœ¨ Debug completed!\n"
      }
    }
  }
};

export class I18nService {
  private static instance: I18nService;
  
  private constructor() {}

  public static getInstance(): I18nService {
    if (!I18nService.instance) {
      I18nService.instance = new I18nService();
    }
    return I18nService.instance;
  }

  async initialize(language: string = "en"): Promise<void> {
    const lng = language.toLowerCase().startsWith("it") ? "it" : "en";
    await i18next.init({
      lng,
      fallbackLng: "en",
      resources: translations,
    });
  }

  t(key: string, options?: any): string {
    return i18next.t(key, options) as string;
  }

  getLocale(): string {
    return i18next.language === "it" ? "it-IT" : "en-US";
  }

  getFullLanguageName(): string {
    return i18next.language === "it" ? "Italian" : "English";
  }
}

export const i18n = I18nService.getInstance();
